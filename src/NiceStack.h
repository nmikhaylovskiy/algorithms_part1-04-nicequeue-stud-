#ifndef NICE_STACK_H_
#define NICE_STACK_H_

#include <string>
#include <stdexcept>
#include <utility>
#include <vector>

//=============================================================================
//  ____          _          _                                     
// |    \ ___ ___| |_    ___| |_ ___ ___ ___ ___    _____ ___      
// |  |  | . |   |  _|  |  _|   | .'|   | . | -_|  |     | -_|     
// |____/|___|_|_|_|    |___|_|_|__,|_|_|_  |___|  |_|_|_|___|     
//                                      |___|                      
//=============================================================================

// Не менять этот файл!


template <class T>
class NiceStack
{
public:
    /// Определение типа элементов стека - пара <значение, минимум-среди-всех-элементов-ниже>
    typedef std::pair<T, T> TypeElementStack;

public:
    /// Создает NiceStack с вместимостью capacity.
    /// Конструктор объявлен "для явного вызова".
    explicit NiceStack(size_t capacity);

    /// Деструктор. Нужен ли тут деструктор?
    ~NiceStack();
protected:
    // Конструкторы и деструкторы всегда стараемся держать рядом, но закрытые запускаем после открытых,
    // даже несмотря на то, что порядок секция нарушается.
    // Вопрос: почему не определяем (или не закрываем) здесь КК и ОП?!

    /// Нельзя создавать NiceStack по умолчанию. Только с помощью другого конструктора с параметром.
    NiceStack() {}

public:                                                     // используем для логического отделения секции конструкторов

    // Возвращает число элементов, реально находящихся в стеке.
    size_t size() const;

    // Возвращает емкость стека в элементах.
    size_t capacity() const { return _capacity; }

    /// Положить новый элемент, передаваемый по ссылке, чтобы избежать копирования.
    /// Возникает исключение out_of_range если стек полный.
    void push(const T& newelement);

    /// Извлечь вершину стека.
    /// Возвращается значение верхнего элемента стека и верхний элемент
    /// удаляется из стека.
    /// По этой причине возвращаем его по значению — т.е. происходит копирование
    /// элемента.
    /// Возникает исключение out_of_range, если стек пустой.
    T pop();

    /// Показать вершину стека.
    /// Возвращается ссылка на верхний элемент стека, который остается
    /// в стеке.
    /// Возвращаемая ссылка действительна до первого вызова pop.
    /// Возникает исключение out_of_range, если стек пустой.
    const T& top() const;

    /// Возвращает значение минимального элемента в стеке.
    /// Т.е. соответствующая область памяти остается на своем месте (элемент стека), имеем
    /// возможность вместо копии вернуть константную ссылку на объект, что в случае с любыми
    /// объектами, чуть более сложными, чем POD-типы, будет стоить дешевле.
    /// NB: с примитивными типами возврат по значению обычно дешевле. Поэтому в "профессиональных"
    /// контейнерах с помощью т.н. traits-классов определяется RVal тип: по значению (копия) —
    /// используется для примитивов, либо по const & — для сложных типов. Т.е. в результате
    /// для любого типа шаблона получаем наиболее оптимальную реализацию.
    const T& getMinimum() const;

protected:
    std::vector<TypeElementStack> _storage;         ///< Вектор элементов стека.
    size_t _iHead;                                  ///< Индекс головы стека.
    size_t _capacity;                               ///< Вместимость стека.
};


#include "NiceStack.hpp"

#endif // NICE_STACK_H_
